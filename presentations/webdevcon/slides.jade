section
    h1 Observable web
    h3 Untangling async 
        div.fragment completely

    p.author-name Ganesh Shanmugasundaram
    aside.notes   Welcome to Observable web
        |    Untangling async, when i thought of using this tagline, 
        |    i searched the internet to see if anyone else has used anything similar already.  
        |    Interestingly i found another presentation last year with exactly the same tagline.
        |    That presentation was presenting Javascript Promises as a solution to the async problem 
        |    and a year later, we're dealing with the same problem, slightly differently this time.
        | ====== down =====
        |    So, had to change the tagline to "untangling async completely".
        |    Hope to solve it completely this time.
        |    Hello all, I'm Ganesh Shanmugasundaram.

section
   img.center.logo(src=require('./img/logo.png')) 
   img.fragment.center.london(src=require('./img/london.png'))
   .source http://www.timmythetaxi.com/index_files/stacks_image_52_1.png
   
   aside.notes I'm a Web Development Engineer at the Bookdepository,
        | ====== down ===== 
        | an Amazon subsidiary based in London.
        | We are an online book seller.
        | We sell through our own website bookdepository.com and through Amazon Marketplace.
        | We deliver worldwide for free,
        | a service not offered by many retailers.
        | Without further ado,
        | let's get started.

section
    h1 Webdevs
    ul
        li.fragment Javascript everyday?
        li.fragment Maintain code?
        li.fragment Good code
   
    aside.notes Firstly,
        | i'd like to ask a couple of questions
        | ====== down =====
        |  how many of you use javascript everyday? could be work or fun?
        | could be working on a simple UI interaction or a full blown single page app. anything..
        | [q]
        | ====== down =====  
        | how many people maintain code that someone else has left behind?
        | [q]
        | ====== down =====
        | How many people have worked with good code and write good code?
        | [q]
        | I know we all write good code, no one wants to write bad code,
        | except for that guy who left you to maintain his code.
        | In this talk, i'd like to discuss one major problem i've been 
        | or we've been dealing with in our day to day webdev life,
        | and the solutions we've come up with over the course of the internet.


section
    h1 A feature
    ul
        li.fragment Thought process
        li.fragment Series of steps
        li.fragment User story
    
    aside.notes Building a feature
        | When i get asked to build a feature big or small on the website,
        | ====== down =====
        | this is how my thought process works
        | ====== down =====
        | i try to break it down into smaller chunks and think about it in a series of smaller steps,
        | i guess most of us do that.
        | ====== down =====
        | in addition, i like to create user stories and think about the pseudo code first 
        | before starting to code
        
section
    h1 User story
    ul
        li.fragment Type something in search box
        li.fragment Show search suggestions
        li.fragment Update suggestions
    
    aside.notes Let's talk about a user story here
        | ====== down =====
        | - when a user types something in the search box
        | ====== down =====
        | - display a list of search suggestions under search box
        | ====== down =====
        | - the suggestions should update with more relevant ones  as the user types further
        | the feature is a trivial search auto-suggest 
        | that you can find in most websites today.

section
    h1 Pseudocode
    ul.pseudocode
        li.fragment Get input from the user
        li.fragment Get Suggestions
        li.fragment Display result
        li.fragment Repeat
    
    aside.notes a pseudo code for that feature would look something like this
        | ====== down =====
        | - get input from user
        | ====== down =====
        | - query server and get suggestions
        | ====== down =====
        | - display results
        | ====== down =====
        | repeat till the user has found his result
        | sounds quite simple isn't it?
        | That's what i think when i start building any new feature.
 
section
    h1 Handling async
    img.fragment.center(src=require('./img/callbacks-everywhere.jpg'))
    .source https://memegenerator.net/instance/55965175    
    
    aside.notes however, when i go about implementing it, 
        | I get to deal with keyboard events, network requests etc. 
        | which are asynchronous in nature. 
        | which makes it not so simple anymore.
        | so, how have been handling the async events.
        | ====== down =====
        | traditionally the protocol for dealing with such events is via callbacks.
        | let's try implementing this the callbacks way.

section
    h1 Step 1: Input
    pre
        code.javascript searchBox.addEventListener('keyup', (e) => {
            |     let text = e.target.value;
            | });
            
    aside.notes the first step is to get what the user has typed.
        | we attach an event listerner to the input field, 
        | listen for the keyup event 
        | and get what the user has typed so far
        
section
    h1 Step 2: Suggestions
    pre
        code.javascript  searchBox.addEventListener('keyup', (e) => {
            |    let term = e.target.value;
            |    performSearch(term, (result) => {
            |        
            |    });
            | });
            
    aside.notes now that we got the text, let's query the server and get the suggestions,
        | for simplicity's sake let's assume performSearch does the ajax request to the server.
        | we've got the result now.
            
section
    h1 Step 3: Render
    pre
        code.javascript const searchBox = document.getElementById('searchbox');
            | searchBox.addEventListener('keyup', (e) => {
            |     let term = e.target.value;
            |     performSearch(term, (result) => {
            |         displayResult(result);
            |     });
            | });
     
     h2.fragment Good code? 
     
     aside.notes let's display it to the user.
        | again for simplicity sake, 
        | let's assume we have a function displayResult
        | which renders the result under the search box.
        | and that would complete our feature.
        | the code works, does what we wanted it to do.
        | ====== down =====
        | Ok, now, is that good code? would you be happy if you were left with that code to maintain?
        | I wouldn't mind maintaining that code. 
        | That code is simple,
        | easy to read and understand
        | I can maintain it.

section
    h1 Done!
    img.center(src=require('./img/peter-jumping.png'))
    .source http://az616578.vo.msecnd.net/files/2016/03/13/635934353526140175-155829625_peter%20griffin%20midterms%20sb2k16%20article.jpg
    aside.notes so we're done with the feature now
        | let's do some refactoring,
        | get our code peer reviewed,
        | write some tests. 
        | deploy it to production! 
        | That feature is done!
        | We'll never ever have to go back to that code again forever.
        | I wish things were like that!

section
    h1 Wait!
    img.center(src=require('./img/website-never-done.jpg'))
    .source http://static1.squarespace.com/static/54610ebbe4b08eea0ace557c/t/5551f7fee4b08237a7879a4f/1431435264658/
    aside.notes But Wait! a website is never done!
        | We launched this feature. 
        | A Simple one, but useful to the users.
        | The next day i received an email from one of my co-workers

section
    blockquote.left Love the new auto suggest feature you guys have launched. 
        | But it acts a bit weird sometimes.
        
    aside.notes it read,  "Love the new auto suggest feature you guys have launched.
        | But it acts a bit wierd sometimes. Could you please check?"
        | He was not a technical person and didn't provie any technical information.
        | It's great that he likes the feature,
        | but it's bad that the feature breaks at times.
        | So, I thought before i get back to him asking for more information, 
        | let me do some sanity check,
        | just to make sure there's isn't anything obvious that we missed 
        | or the tests have missed.
        | i opened up my dev box,
        | tested it across different browser and devices
        | and it worked on all the browsers,
        | even in the old ones
        | So i emailed him back saying,
        | i wasn't able to find any issue, 
        | could you give me some more information on the issue?
        | like what was happening,
        | the browser version,
        | some screenshots may be.
        | That'll hopefully give us enough information to get started.
        
section
   blockquote.left 
        span I was on the tube this morning, I was trying to search for a book, 
            | typed "android" and it showed me android app development books,  
        span.fragment but before i could click on it, the results changed quickly, to show "snail and the whale".<br><br> 
        span.fragment I had to press backspace and type "android" again to get to the book, and it worked the second time. 
            | The same issue happened a few times during my journey 
        span.fragment  I'm on Nexus 6 with latest version of Chrome. 
            | I can't seem to reproduce the issue now though, seemed to have fixed itself!
    aside.notes And then i got a reply, which read
        | I was on the tube this morning, I was trying to search for a book, 
        | typed "android" and it showed me android app development books,  
        | ====== down =====
        | but before i could click on it, the results changed quickly, to show "snail and the whale".<br><br> 
        | I had to press backspace and type "android" again to get to the book, and it worked the second time. 
        | The same issue happened a few times during my journey
        | ====== down ===== 
        | I'm on Nexus 6, on latest version of Chrome. 
        | I can't seem to reproduce the issue now though, seemed to have fixed itself!
        | We all love the issue that fixes itself.
        | That reply provided more information for us to get started.
        | So where did we start, we checked the servers probably an issue with cache
        | or one of the instance is running old code etc.
        | But they were fine, so the issue was not 
        | with the backend but was with the front-end itself.
        | We figured out, There was a race condition happening
        | in the network requests that was causing this issue
        
section
    h1 Extended scenario
    ul
        li.fragment On Tube 
            span.fragment or Metro
        li.fragment Mobile internet 
        li.fragment Trying to find a book
        
    aside.notes we have an extended use case
        | ====== down ===== 
        | a user who is on the tube as the Londoners call it 
        | ====== down ===== 
        | or a Metro as most of the world calls it.
        | ====== down =====  
        | he's on mobile network connection,
        | trying to find a book,
        | using the feature we just launched.
        | he's facing some issues, 
        | mostly because of the changes in the environment

section
    h1 Things to consider
    ul
        li.fragment Network bandwidth
        li.fragment Unstable network
        li.fragment Data cost
        li.fragment Device constraints
        
    aside.notes 
        | What kind of environment issues should we consider for this use case?
        | ====== down ===== 
        | - network might be slow, depending on the type of connection he's on.
        | ====== down =====  
        | - network might be unstable, since he's on a train and moving really fast,
        |  some network requests might fail
        |  the trains in europe are way faster than the ones here
        | ====== down ===== 
        | - data cost, depending on the plan he is, there's going to be a network cost.
        | ====== down ===== 
        | - the device might be slow or low on memory 
        | We would want to cater for that user as well, 
        | because he buys our books, 
        | he's our potential customer
        | so let's improve our feature to accomodate this specific use case

section
    h1 Improvements
    ul
        li.fragment Reduce network requests
        li.fragment Remove duplicate requests
        li.fragment Handle race condition
            
    aside.notes how could we improve?
        | ====== down ===== 
        | - reduce the number of requests we make, that'll be quite useful especially in terms of bandwidth, and data costs.
        | in this case, let's say we query the server
        | only when the user stops typing for about 100 milliseconds
        | we can  add some debounce logic to achieve that[100ms]
        | ====== down ===== 
        | - remove duplicate requests
        | you don't want to make the same request to the server more than once.
        | that'll save some cost and time
        | ====== down ===== 
        | - avoid race conditions, make sure we show the results for the latest value in the search box.
        | this will address the issue we saw earlier.
        | ok, so we've figured out what we want to do, 

section
    h1 Debounce
    pre
        code.js const searchBox = document.getElementById('searchbox');
            | var requestTimer = null;
            | searchBox.addEventListener('keyup', (e) => {
            |     let term = e.target.value;
            |     clearTimeout(requestTimer);
            |     requestTimer = setTimeout(() => {
            |         performSearch(term, (result) => {
            |             displayResult(result);
            |         );
            |     }, 100);
            | });
            
    aside.notes let's deal with the improvements one at a time. 
        | First one is reducing the number of request.
        | implement some debounce logic 
        | so, how do we implement debounce logic,
        | let's use the age old method of adding a setTimeout,
        | and move the timeout to 100 milli seconds, everytime we get a keyup event
        | that's the code for that
        | and it gets harder to read now.
        | That in my opinion is not good code.

section
    h1 More problems
    ul
        li.fragment state
        li.fragment callback hell
        li.fragment one more problem...
        
    aside.notes now we have more problems
        | ====== down =====
        | - we've introduced a state for the timer which makes it harder to test
        | ====== down =====
        | - we've gotten into the callback hell!
        | ====== down =====
        | also, did anyone spot anything else that was wrong with the code?
              
section
    img(src=require('./img/brace.jpg'))
    
    aside.notes it was missing a curly brace
        | this is one of the symptoms of callback hell. 
        | you need an IDE or a linter to work with such code
        | the code gets harder to maintain as we add more changes.
        | this code is not extendable either. 

section
    blockquote Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.
    
    aside.notes This is something i read on the internet, and is quite true
        | Always code
        | as if the person who ends up maintaining your code
        | is a violent psychopath who knows where you live.
        | And i always fear that guy, 
        | so, let's see how we can refactor our code
        | As usual, i go to google and asked how do i get out of the callback hell
        | and it said Promises
    
section
    h1 Promises may be?
    ul
        li.fragment chainable
        li.fragment readable code
        li.fragment browser support
        li.fragment handle error
    
    aside.notes May be promises will save us then?
        | ====== down =====
        | Promises are chainable.
        | ====== down ===== 
        | they are more readable and comprehendable.
        | ====== down =====
        | most modern browsers support promises, 
        | and there are polyfills for the older ones,
        | which is great.
        | ====== down =====
        | they can handle exception, 
        | atlease better than callbacks

section
    h1 Promises in action!
    ul
        li.fragment one value
        li.fragment no modify
        li.fragment no cancel
    
    aside.notes let's looks at some constraints of promise
        | before using them in our code.
        | you don't want to regret later right?
        | ====== down =====
        | - a promise must only resolve once. and it can have only one value
        | ====== down =====
        | - when you create a promise 
        | it's on it's way to be resolved or rejected, 
        | it can't be modified later.
        | ====== down =====  
        | - Promises can't be cancelled, 
        | you can discard the value the promise resolved, 
        | but you can't cancel the operation.
        | promise doesn't look that promising.
        | but let's see how our code looks like if we rewrite it using promise.
        | even a small improvement is still an improvement

section
    h1 Promisified
    pre
        code.javascript const searchBox = document.getElementById('searchbox');
            | var requestTimer = null;
            | searchBox.addEventListener('keyup', (e) => {
            |     let term = e.target.value;
            |     clearTimeout(requestTimer);
            |     requestTimer = setTimeout(() => {
            |         fetch('/search?term='+term)
            |             .then((resp) => {
            |                 return resp.json();
            |             }).then((result) => {
            |                 displayResult(result);
            |             })
            |     }, 300);
            | });
    
    aside.notes since a promise can resolve only once,
        | the keyup event can't be promised, 
        | as it'll emit multiple values
        | the debounce step using setTimeout can't be promised either,
        | as we'll need a way to modify the delay.
        | and promises can't be modified.
        | the ajax call can be a perfect candidate for promises, 
        | in fact there is a fetch API available in most modern browsers which provides
        | a clean interface for making ajax request.
        | so, when we re-wrote our code using promise,
        | the ajax bit looks a bit cleaner and followable 
        | but the rest remains the same. 
        | it's still unmaintainable.

section
    h1 Simple feature?
    img(src=require('./img/grind-gear.png'))
    p.fragment.disapprove ಠ_ಠ
    
    aside.notes we started out with a simple 3 step user story,
        | and we ended up in this mess 
        | and we haven't even completed our feature yet, 
        | we've got 2 more enhancements left.
        | what's frustrating is that we can't build a simple feature in a simple way.
        | can we do better than this? 
        | can we make it more readable /  maintainable?
        | more importantly extendable.
        | may be use a framework or library?
        | everytime i tell that non-js dev friends a new framework or library in javascript 
        | i get a look of disapproval.
        | Because there is a new library getting released out there every day
        | Shouldn't this be a feature in the language rather than a library?
        | a language shouldn't force you to write bad code?
        | especially a language that powers nearly all the websites.
        | so, let me introduce you to 
        | a new object type called Observables.

section
    h1 Observable
    ul
        li.fragment Modelling async data
        li.fragment Lazy Stream
        li.fragment Emits 0 -> n values
        li.fragment May or may not finish
    
    aside.notes Let's see observables can do here, but before that, let's see what observables are
        | Bluntly put, 
        | ====== down =====
        | an observable is an object type for modelling async data.
        | ====== down =====
        | it's a lazy stream of events
        | ====== down =====
        | It pushes or emits zero to n values over a period of time.
        | ====== down =====
        | May or may not finish

section
    h1 Where does it fit?
    ul
        li.fragment Primitive: sync + single value
        li.fragment Iterator: sync + multiple value
        li.fragment Promise: async + single value
        li.fragment
            span.fragment Observable: 
            span   async + multiple value
    
    aside.notes More clearly,
        | ====== down =====  
        | If it's a synchronous operation, like generating a random number or any computation
        | and returns a single value, it can be represented by primitives like string, number etc.
        | ====== down =====  
        | If it's synchronous operation and returns multiple values, 
        | it can be modelled iterators. A JS array or generators are good examples.
        | ====== down =====  
        | If it's asynchronous operation and emits a ONLY a single value,
        | it can be modelled as a promise.
        | ====== down =====  
        | And finally, this is where there is some hollow space 
        | as we don't have anything compelling at the moment
        | to model something asynchronous and emits multiple values,
        | ====== down =====  
        | and Observable fills in this space
        | Now that brings us to another question,
        | so do i have to learn another API?
        | new syntax again?
        | well, yes.. but it's easier than you think.
        | The learning curve is quite flat actually if you're used to promises.

section
    h1 Syntax ~ Promise
    pre
        code.javascript const p = new Promise();
            | p.then(onResolve, onReject);
    
    aside.notes So, let's see how to use an observable,
        | The syntax is similar to promise,
        | so if you've used promises before,
        | you'll be comfortable using observable.
        | In promise, we usually call 'then' on the promise
        | passing onResolve and onReject functions.
        | that's a promise.
        | when the promise resolves, onResolve is called
        | and when it's rejected onReject is called.

section
    h1 Subscribe vs then
    pre
        code.javascript const ob = new Observable({});
            | ob.subscribe(onNext, onError);
            
    aside.notes In Observable, 
        | we use subscribe instead of then.
        | We pass onNext and onError functions.
        | The onNext gets called every time 
        | the observable emits a value.
        | The onError gets called when there is an error or an exception.

section
    h1 onComplete
    pre
        code.javascript const ob = new Observable({});
            | const subscription = ob.subscribe(onNext, 
            |                                    onComplete,
            |                                    onError);
    
    aside.notes Since it can emit multiple values,
        | we need a way to see when it's complete, 
        | so we pass a onComplete function as well.
        | onComplete will get called when all the values are emitted.
 
 section 
    h1 Unsubscribe
    pre
        code.javascript const ob = new Observable({});
            | const subscription = ob.subscribe(onNext, 
            |                                    onComplete,
            |                                    onError);
            | subscription.unsubscribe();
    
    aside.notes observables can emit multiple values, 
        | we'll need a way to say stop sending me events
        | we just call unsubscribe on the subscription
        | this will do the clean up operations if any.

section
    h1 Creating an Observable
    pre
        code.javascript $obs = new Observable(observer => {
           |        observer.next(1);
           |        observer.complete();
           | 
           |        return _ =>  {
           |            console.log('unsubscribed');
           |        }
           | }); 
           | subs = $obs.subscribe(onNext, onComplete, onError);
           | // 1 <-- onNext
           | // complete <-- onComplete
           | subs.unsubscribe()
           | // unsubscribed
           
    aside.notes So, we saw how to subscribe to an observable,
        | let's see how to create an observable.
        | But before that, How many of you have used promises?
        | How many of you actually create promise from scratch?
        | So, the Observable takes in a function which receives an observer.
        | observer will have 3 methods next, complete and error
        | We call the observer.next when we want to push or emit a value
        | In this case we call with value 1
        | we call observer.complete when we've done pushing all the values
        | we call observer.error when there's an error 
        | finally, this returns a function, this will be called on unsubscription   
        | that's a very simple obsevable which emits 1 when you subscribe.
        | calls oncomplete right after the first value
        | and prints unsubscribed on unsubscription
        | That's not a useful observable though, 
        | it just emits one value.

section
    h1 Creating an Observable
    pre
        code.javascript $clickObs = new Observable(observer => {
            |     const element = document.getElementById('btn');
            |     const handler =  (evt) => {
            |         observer.next(evt);
            |     };
            |     
            |     element.addEventListener('click', handler, true);
            |     
            |     return _ =>  {
            |         element.removeEventListener('click', handler, true);
            |     }
            |     
            | });
            | subs = $obs.subscribe(onNext, onComplete, onError);
            | // click
            | // [event info]
            | // click
            | // [event info]
            
    aside.notes let's see how we'll model an actual async event
        |  we attach an click event listener on a button, 
        |  and every time the button is clicked observer.next is called with the event info
        |  so, onNext function will be called with the eventInfo everytime the button is clicked
        |  we don't call observer.complete or observer.error here, so the onComplete or error will never be called.  
        |  And we return a clean up function which will remove the listener from the button.
        | So, unsubscription will remove the event listener from the button
        | Not complicated, straight forward.

 section
    h1 What?
    ul
        li.fragment Keyboard events
        li.fragment Mouse events
        li.fragment Animation
        li.fragment Lifecycle events
        li.fragment XHR requests
        li.fragment WebSocket requests and messages
        li.fragment everything else...
   
    aside.notes In our auto-suggest we said 
        | only the ajax request is a good candidate for a promise. 
        | So, what about observables?
        | what can be modelled into observables. 
        | if you take a look at the browser events, we have
        | ====== down =====  
        | - keyboard events like keyup / keydown etc.
        | they emit values everytime user types.
        | they can be observables.
        | except the oncomplete will never get called.
        | ====== down =====  
        | - Mouse events like mouse click, mouse up / down etc can be observables
        | ====== down =====  
        | - Animation events start, end, iteration can be observable.
        | they'll have an oncomplete event triggered.
        | ====== down =====  
        | - lifecycle events settimeout, request animation frame,
        | they can be modelled to observable
        | ====== down =====  
        | - ajax calls,
        | they emit just 1 event, a success or a failure.
        | most of use promises nowadays for this, but they can be observables
        | ====== down =====  
        | - websocket events where data is pushed for every message,
        | they're good candidates for observables.
        | ====== down =====  
        | - so, nearly all the events that we encounter while we build apps can be observables. 
        
section
    h1 Event emitter?
    ul
        li.fragment Observer pattern
        li.fragment Both emit 0 - n values
        li.fragment Subscription
        li.fragment Lazy ( or cold )
        li.fragment Operation happens on subscription 
        li.fragment One subscriber ( default )
    
    aside.notes How many of you work on nodeJS? 
        | If you've worked on a nodeJS system, 
        | [q]
        | you'd be familiar with the concept of event emitters, they're everywhere in node.
        | When i first learnt about observables, 
        | i thought they look quite similar to event emitters.
        | I even thought they were event emitters for the browser?
        | But they are different
        | ====== down =====  
        | They both implement the observer pattern.
        | ====== down =====  
        | They both emit  multiple values.
        | ====== down =====  
        | And can be subscribed on.
        | ====== down =====  
        | However, Observables are lazy in nature, 
        | they're Cold
        | nothing happens when you instantiate the observable.
        | ====== down =====  
        | Actual operation like the ajax request happens only on subscription.
        | While in case of event emitter, 
        | the events are emitted no matter if you're listening or not
        | ====== down =====  
        | An observable will have one subscriber by default. 
        | subscribing on observable multiple times 
        | will cause it to perform the operation on each subscription
        | and each subscriber will get different values.
        | which is quite different from event emitters.

section
    h1 What's so special?
    ul
        li.fragment Unified protocol
        li.fragment Transformable
        li.fragment Composable
        li.fragment Array#Operators like map, forEach, reduce etc.
    
    aside.notes so, what's so special about observable?
        | Their syntax is similar to promise,
        | but allows for multiple value to be emitted, yea, yea that's fine.
        | But that's not really compelling right?
        | So, what makes it special?
        | That we'll be happy to go through the pain of learning a new syntax.
        | ====== down =====  
        | A few things actually, it could act as a unified protocol for all the async events.
        | So, you want to represent something that emits just one value, you can use an observable
        | you want to represent something that emits a zillion values, you can use observables for that too. 
        | you can even wrap a synchrnous operation in an observable.
        | ====== down =====  
        | They're transformable, 
        | you can apply transformation so each value emitted will be transformed to a different value.
        | ====== down =====   
        | Composable, you can combine 2 or more observable to make a third one.
        | ====== down =====
        | And you can make them behave like inverted iterators  
        | which means we can extended array operators like map, reduce, filter, forEach. 
        | And you can create your own operators as well if required.
        | That in my opinion is the best bit about Observables.

section
    h1 Iterable
    pre
        code.javascript [1,2,3].map(x => x*x)
            |        .reduce((x, sum) => sum+x, 0);
            | // 14
            
    aside.notes Let's take the following example,
        | we're transforming an array [1,2,3]
        | what we're doing here is mapping each value of the array to it's square, 
        | so we get a new array with [1,4,9]
        | then the reduce operation returns the sum of the squares.
        | So we're transforming the array into a single number and in this case the value is 14.

section
    h1 Subscribe
    pre
        code.javascript $clickObs.subscribe(onNext, onComplete, onError);
            | // event [Object]
            | // event [Object]
            | // event [Object]
            
    aside.notes You can perform similar operation on an observable.
        | As for Observables, we can treat each event like a value of the array
        | We get a click eventInfoObject emitted everytime there's a mouse click.
            
section
    h1 Map Clicks
    pre
        code.javascript $clickObs
            |   .map(x => 1)
            |   .subscribe(onNext, onComplete, onError);
            | // 1
            | // 1
            | // 1
            
    aside.notes  We can map each of the event to a value of 1
        | the new transformed observable will now emit 1 rather than the event information.
        | But that wouldn't work out of the box.
        | Observable is not an Iterator, we can make it behave like an inverted iterator.

section
    h1 Transformable
    pre
        code.javascript Observable.prototype.map = function (fn)  {
            |       return new Observable((observer) => {
            |            this.subscribe((nextVal) => {
            |                const newVal = fn(nextVal); 
            |                observer.next(newVal);
            |            }, observer.complete, observer.error);
            |       });
            | }
            
    aside.notes Let's implement a simple map function on the observable
        | This is how it'll look like
        | it creates a new observable
        | what the new oberservable does is it subscribes to the parent observable
        | and when the parent emits a value, 
        | it applies the function we pass on the value
        | and emits the new value. 
        | This will make the map work 

section
    h1 Reduce
    pre
        code.javascript $clickObs
            |       .map(x => 1)
            |       .scan((x, y) => x+y)
            |       .subscribe(onNext, onComplete, onError);
            | // 1
            | // 2
            | // 3
    
    aside.notes  we can perform reduce operation on the new observable,
        |  we're using scan which reduces the values emitted so far.
        | and the resulting observable will emit, sum of the the values emitted so far. 
        | that's a simple click counter implemented in 4 lines.
        | this is useful when you want to extend the features you built, 
        | which you will have to in most cases. 
        | if you look at it deeply, there are no states involved, 
        | we didn't have to keep track of how many times a user has clicked
        | if you're into functional programming,
        | you'll love Observables just for this. 
        | and it's easier to test

section
    h1  Browser support?
    ul
        li.fragment well...
        li.fragment Still in tc39 proposal
        li.fragment Stage 1
        li.fragment Not for ES2016 / ES7
        li.fragment But...
    
    aside.notes so, observables are great tool for modelling async,
        | how about the browser support
        | ====== down =====   
        | Well, that's the tricky part.
        | ====== down =====    
        | It's not part of the standards yet and doesn't ship with any of the browsers
        | ====== down =====   
        | It's at stage 1 for the tc39 process, which means it's proposed.
        | ====== down =====   
        | It didn't make it into ES 2016,
        | ====== down =====    
        | but it should make it into the next release 
        | which is not that far away
        | But that said, 
        | it shouldn't stop us from using observable today.

section
    h1 Projects
    ul
        li.fragment rxJS
        li.fragment baconJS
        li.fragment Angular 2 (http)
        li.fragment more...
    
    aside.notes as there are a lot of libraries supporting Observables
        | ====== down =====    
        | RxJS is one of the mature ones, 
        | it provides APIs for creating observables from events, 
        | promises, event streams, callbacks, virtually anything. 
        | It also provides over 200 operators to 
        | compose and transform observables. Scan is one of their operators. 
        | It has a huge community, and good documentation. 
        | They're trying to make their implementation of Observable 
        | to align with the standards Observable.
        | ====== down =====   
        | baconJS, a light weight functional reactive programming library.
        | They let you treat your events as stream, 
        | similar concept as observables.
        | And they provide bunch of operators to manipulate the streams. 
        | Not as extensive as rxJS, but supports most of the use cases.
        | How many angular users do we have here?
        | [q]
        | So, Angular 1, was filled with promises.
        | it used promise extensively, especially for the http provider.
        | ====== down =====   
        | Angular 2.0 will be using Observable, currently supported by rxJS.
        | there are a few other projects which implement observables,
        | ====== down =====   
        | cycle.js is another big one..
        | So, there is a huge community behind Observables and people have started thinking in terms of observables.
        | definitely worth using it.

section
    h1 AutoSuggest
    pre
        code.javascript const searchObs  = Observable.fromEvent(searchBox, 'keyUp');
            | searchObs.subscribe(onNext, onComplete, onError);
            | // [evt Object]
            | // [evt Object] 
            | // [evt Object] 
            | // [evt Object] 
            | // [evt Object] 
    
    aside.notes And, coming to our auto-suggest box problem. 
       |  Let's see how to implement that using Observable.
       |  I've done it using RxJS, 
       |  but the implemenation should be similar if you use other libraries too.
       |  Or even if you create it from scratch.
       |  First thing we have to create an observable for the key-up event,
       |  we can do it from scratch like the way we did with the click event.
       |  I've done it using the Observable.fromEvent function provided by RxJS
       |  if we subscribe to that observable, that'll emit event objects


section(data-transition="fade")
    h1 AutoSuggest
    pre
        code.javascript const searchObs  = Observable.fromEvent(searchBox, 'keyUp')
            |           .map(e => e.target.value);
            | searchObs.subscribe(onNext, onComplete, onError);
            | // a
            | // an
            | // and
            | // andr
            | // andr  <-- use has pressed a non char key
            | // andro
    
    aside.notes we can then map those events to the target value, 
        | which is the text inside the search box 
        | we've not got an observable that emits text now.


section(data-transition="fade")
    h1 AutoSuggest
    pre
        code.javascript const searchObs  = Observable.fromEvent(searchBox, 'keyUp')
            |            .map(e => e.target.value)
            |            .flatMap( term => fetch('/search?term='+term).then(resp => resp.json() ) );
            | searchObs.subscribe(onNext, onComplete, onError);
            | // [Result Object]
            | // [Result Object]
            | // [Result Object]
            | // [Result Object]
            | // [Result Object]
            | // [Result Object]
    
    aside.notes we can then map the text we got to a fetch event
        | which returns a promise. 
        | here we're using flatmap which is another rxjs operator
        | what that does is it returns the resolved value promise rather than the promise itself 
        | in our case it returns the server response in JSON
        | we can subscribe to this, 
        | and the onNext will receive the result which can be displayed to the user.
        | that's our basic implementation, it wasn't too hard was it?
        | how about the enhancements, that's where the problem started last time.

section(data-transition="fade")
    h1 Enhancements
    pre
        code.javascript const searchObs  = Observable.fromEvent(searchBox, 'keyUp')
            |            .map(e => e.target.value)
            |            .debounce(100)
            |            .flatMapLatest( term => {
            |                return fetch('/search?term='+term).then(resp => resp.json() ); 
            |            });
            | searchObs.subscribe(onNext, onComplete, onError);
            | // [Result Object]
            | // [Result Object]
    
    aside.notes Let's do the improvements we talked about.
        | first one is reducing the number of requests,
        | add some debounce logic.
        | we add an operator called 'debounce', 
        | again provided by rxjs
        | that'll block the flow till the data emission is stopped for 100 ms 
        | and then make the request

section(data-transition="fade")
    h1 Enhancements
    pre
        code.javascript const searchObs  = Observable.fromEvent(searchBox, 'keyUp')
            |            .map(e => e.target.value)
            |            .debounce(100)
            |            .distinctUntilChanged()
            |            .flatMapLatest( term => {
            |                return fetch('/search?term='+term).then(resp => resp.json() ); 
            |            });
            | searchObs.subscribe(onNext, onComplete, onError);
            | // [Result Object]
    
    aside.notes let's add some logic which stops duplicate request
        | we add distinctUntilChanged operator again from RxJS
        | so, the network request is made only when the text value changes.

section(data-transition="fade")
    h1 Enhancements
    pre
        code.javascript const searchObs  = Observable.fromEvent(searchBox, 'keyUp')
            |            .map(e => e.target.value)
            |            .debounce(100)
            |            .distinctUntilChanged()
            |            .flatMapLatest( term => {
            |                return fetch('/search?term='+term).then(resp => resp.json() ); 
            |            });
            | searchObs.subscribe(onNext, onComplete, onError);
            | // [Result Object]
    
    aside.notes we replace flatMap with flatMapLatest
        | which returns only the result of the latest value,
        | which will fix the bug our co-worker experienced on the train.
        | now, that's is readable code, 
        | it's easy to follow and extend.
        | in my opinion that's way better than the code we had earlier.  
        | ok, so we've been using 3 non-standard operators here, 
        | the ones provided by RxJS
        | what if we have an issue that an operator cannot solve?
        | that's unlikely as they have more than 130 operators to address most of our needs,
        | also, thaks to es6 imports, 
        | you can just import the operator you need for your use case which will keep the package light weight
        | but what if i don't want to use rxJS
        | well, there are other libraries we listed earlier like baconJS, kefir etc.
        | they implement similar operators
        | but if we still need to,
        | we can write our operators.
        | like we did with map operator

section
    h1 tl;dr
    ul
        li.fragment think reactive
        li.fragment data + operation
        li.fragment start using observables today
        li.fragment libraries for now
        li.fragment write clean code
        li.fragment think about that guy
        li.fragment it might be you
        
    aside.notes stop thinking about callbacks
        | ====== down =====   
        | think reactive
        | ====== down =====
        | don't mix data and logic, keep them separate
        | start thinking in terms of data and operations,
        | use observable to model the data
        | operators to performa the operations  
        | they make extending features simple
        | ====== down =====
        | they may not be part of standards yet,
        | but there are  the libraries today to get started
        | when Observables make it into the standard, 
        | the libraries will just become a polyfill wrapper around  the standard implementation
        | ====== down =====
        | think about that guy who is going to maintain your code
        | ====== down =====
        | most probably it might be yourself

section
    h1 Q/A